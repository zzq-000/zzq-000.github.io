<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2022/09/01/abstract-factory-pattern/</url>
    <content><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在<a href="https://bill_david.gitee.io/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>工厂模式</strong></a>中提到，为了解决简单工厂模式的不足（不满足开闭原则），工厂模式将工厂类抽象为一个公共类，只定义了基本的接口，而将对象的创建工作推迟到其子类中，这样当我们新增一个产品类的时候，只需要创建一个该产品类对应的工厂，并且继承公共的工厂类即可。</p>
<span id="more"></span>
<p>抽象工厂模式，就好比是多个工厂方法模式的叠加。抽象工厂创建的是一系列相关的对象，其中创建的实现其实就是采用的工厂方法模式。在工厂Factory中的每一个方法，就好比是一条生产线，而生产线实际需要生产什么样的产品，这是由工厂类的子类去决定的，这样便延迟了具体子类的实例化；同时集中化了生产线的管理，节省了资源的浪费。</p>
<h3 id="例子-已测试"><a href="#例子-已测试" class="headerlink" title="例子(已测试)"></a>例子(已测试)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeA</span> : <span class="keyword">public</span> Tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Tree A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeB</span> : <span class="keyword">public</span> Tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Tree B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatA</span> : <span class="keyword">public</span> Cat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Cat A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatB</span> : <span class="keyword">public</span> Cat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Cat B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Tree *<span class="title">createTree</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cat *<span class="title">createCat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory1</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tree *<span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Cat *<span class="title">createCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CatA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory2</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tree *<span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Cat *<span class="title">createCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CatB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *factory1 = <span class="keyword">new</span> <span class="built_in">Factory1</span>();</span><br><span class="line">    Tree *tree1 = factory1-&gt;<span class="built_in">createTree</span>();</span><br><span class="line">    Cat *cat1 = factory1-&gt;<span class="built_in">createCat</span>();</span><br><span class="line"></span><br><span class="line">    tree1-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cat1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Factory *factory2 = <span class="keyword">new</span> <span class="built_in">Factory2</span>();</span><br><span class="line">    Tree *tree2 = factory2-&gt;<span class="built_in">createTree</span>();</span><br><span class="line">    Cat *cat2 = factory2-&gt;<span class="built_in">createCat</span>();</span><br><span class="line"></span><br><span class="line">    tree2-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cat2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factory1;</span><br><span class="line">        factory1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tree1;</span><br><span class="line">        tree1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cat1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> cat1;</span><br><span class="line">        cat1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factory2;</span><br><span class="line">        factory2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tree2;</span><br><span class="line">        tree2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cat2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> cat2;</span><br><span class="line">        cat2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>This is Tree A<br>This is Cat A<br>This is Tree B<br>This is Cat B  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>工厂方法模式适用于产品种类结构单一的场合，为一类产品提供创建的接口；而抽象工厂方法适用于产品种类结构多的场合，主要用于创建一组（有多个种类）相关的产品，为它们提供创建的接口；就是当具有多个抽象角色时，抽象工厂便可以派上用场。</li>
<li>简单工厂模式-&gt;工厂模式-&gt;抽象工厂模式 本质上是同一种设计模式，具备层层递进的关系，有利于加深我们对于设计模式的理解和演进</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/09/01/factory-pattern/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>上一篇讲到<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>，简单工厂模式中，我们建立了一个工厂类，当需要某一类对象的时候，将相应参数传给工厂类，由工厂类来决定生成何种对象。但有一个缺点，如果新增一个产品类，那我们将不得不对工厂类进行修改，增加新的业务逻辑，违反了面向对象编程中的开闭原则。</p>
<span id="more"></span>
<p>本文提到的<strong>工厂模式</strong>是对<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>的升级和改进。工厂模式是在简单工厂模式的基础上，对“工厂”添加了一个抽象层。将工厂共同的动作抽象出来，作为抽象类，而具体的行为由子类本身去实现，让子类去决定生产什么样的产品。</p>
<p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<h3 id="示例（已测试）"><a href="#示例（已测试）" class="headerlink" title="示例（已测试）"></a>示例（已测试）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Product</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductA</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is product A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductB</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is product B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductAFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductAFactory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductAFactory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function">Product *<span class="title">createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductBFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductBFactory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductBFactory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function">Product *<span class="title">createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *factoryA = <span class="keyword">new</span> <span class="built_in">ProductAFactory</span>();</span><br><span class="line">    Product *productA = factoryA-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productA-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Factory *factoryB = <span class="keyword">new</span> <span class="built_in">ProductBFactory</span>();</span><br><span class="line">    Product *productB = factoryB-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productB-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factoryA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factoryA;</span><br><span class="line">        factoryA = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> productA;</span><br><span class="line">        productA = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factoryB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factoryB;</span><br><span class="line">        factoryB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> productB;</span><br><span class="line">        productB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>This is product A<br>This is product B  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>在本例中ProductAFactory专门负责ProductA类对象的生成，ProductBFactory专门负责ProductB类对象的生成，如果未来需要新增一个类ProductC，则可以直接继承Factory创建一个ProductCFactory类，负责ProductC类对象的生成，并且测试时也只需单独对一类产品进行测试即可，，符合面向对象设计的原则。</p>
</li>
<li><p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<ul>
<li>在设计的初期，就考虑到产品在后期会进行扩展的情况下，可以使用工厂方法模式；</li>
<li>产品结构较复杂的情况下，可以使用工厂方法模式；</li>
</ul>
</li>
<li><p>感想：工厂模式解决了<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>的弊端，即违反了开闭原则。在简单工厂模式中，如果新增一个产品类，则需要对工厂类方法进行修改，违反了开闭原则，但在工厂模式中，工厂类并不负责实际对象的产生，而是将自身<strong>抽象</strong>为一个<strong>接口</strong>，将创建产品对象这一行为推迟到子类中。这样当新增一个产品类时，我们只需要写一个这个类的工厂，继承统一的接口工厂类，然后再实现这个产品类即可，无需对原有的代码进行修改。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/08/31/simple-factory-pattern/</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式(Simple Factory Pattern):又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建类的实例通常具有共同的父类。</p>
<span id="more"></span>
<h3 id="例子-已测试"><a href="#例子-已测试" class="headerlink" title="例子(已测试)"></a>例子(已测试)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">ProductTypeTa</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeA,</span><br><span class="line">    TypeB,</span><br><span class="line">    TypeC</span><br><span class="line">&#125; PRODUCTTYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductC</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product *<span class="title">create_product</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TypeA:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">        <span class="keyword">case</span> TypeB:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">        <span class="keyword">case</span> TypeC:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductC</span>();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Factory *productFactory = <span class="keyword">new</span> <span class="built_in">Factory</span>();</span><br><span class="line">    Product *productObjA = productFactory-&gt;<span class="built_in">create_product</span>(TypeA);</span><br><span class="line">    <span class="keyword">if</span> (productObjA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjA-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Product *productObjB = productFactory-&gt;<span class="built_in">create_product</span>(TypeB);</span><br><span class="line">    <span class="keyword">if</span> (productObjB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjB-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Product *productObjC = productFactory-&gt;<span class="built_in">create_product</span>(TypeC);</span><br><span class="line">    <span class="keyword">if</span> (productObjC != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjC-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> productFactory;</span><br><span class="line">    productFactory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjA;</span><br><span class="line">    productObjA = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjB;</span><br><span class="line">    productObjB = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjC;</span><br><span class="line">    productObjC = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>This is product A<br>This is product B<br>This is product C</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>优点：实现对象的创建和使用分离，创建完全交给专门的工厂类去负责，程序员不需要关心对象是如何创建出来的，只用关心如何使用即可</p>
</li>
<li><p>缺点：不够灵活，在本例中，如果新增一个产品类，就要修改工厂类，修改其判断逻辑。违反了开闭原则，没有办法做到灵活扩展</p>
</li>
<li><p>感想：其实简单工厂模式就是一种分类讨论的思想，根据用户需求的不同生成不同的对象，将这个分类讨论的逻辑放在工厂类里面，最终生成特定类型的对象</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
