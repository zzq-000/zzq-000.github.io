<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++17 initializer_list</title>
    <url>/2023/08/13/C++-17-initializer-list/</url>
    <content><![CDATA[<p>在C++17中， 对于模版类对象的生成不需要声明模版参数，可以直接进行初始化，模版参数交由编译器去推断</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 t1;</span><br><span class="line">    T2 t2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T1 t1 = <span class="built_in">T1</span>(), T2 t2 = <span class="built_in">T2</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printSizeOfDataTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\nSize of t1 is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t1) &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\nSize of t2 is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t2) &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Until C++14</span></span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">printSizeOfDataTypes</span>( );</span><br><span class="line">    <span class="comment">//New syntax in C++17</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">( <span class="number">1</span>, <span class="number">10.56</span> )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>《Mastering C++ Programming Modern C++17 at Your Fingertips》</tag>
        <tag>C++17新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 static_assert</title>
    <url>/2023/08/13/C++-17-static-assert/</url>
    <content><![CDATA[<p>C++17中新增了static_assert，即静态断言，在编译期就能帮助程序员识别到代码中的一些断言错误, 并且可以在static_assert中加入第二个参数，将字符串直接作为编译结果输出</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Until C++14</span></span><br><span class="line">        MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; obj1;</span><br><span class="line">        obj1.<span class="built_in">printSizeOfDataTypes</span>( );</span><br><span class="line">        <span class="comment">//New syntax in C++17</span></span><br><span class="line">        <span class="function">MyClass <span class="title">obj2</span><span class="params">( <span class="number">1</span>, <span class="number">10.56</span> )</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">static_assert</span> ( <span class="number">1</span> == <span class="number">0</span>, <span class="string">&quot;Assertion failed&quot;</span> );</span><br><span class="line">        <span class="built_in">static_assert</span> ( <span class="number">1</span> == <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">static_assert</span> ( x == y );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ test1.cc -std=c++17</span><br><span class="line">test1.cc: In <span class="keyword">function</span> ‘int main()’:</span><br><span class="line">test1.cc:28:27: error: static assertion failed: Assertion failed</span><br><span class="line">   28 |         static_assert ( 1 == 0, <span class="string">&quot;Assertion failed&quot;</span> );</span><br><span class="line">      |                         ~~^~~~</span><br><span class="line">test1.cc:29:27: error: static assertion failed</span><br><span class="line">   29 |         static_assert ( 1 == 0 );</span><br><span class="line">      | </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>《Mastering C++ Programming Modern C++17 at Your Fingertips》</tag>
        <tag>C++17新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 std::invoke</title>
    <url>/2023/08/13/C++-17-std-invoke/</url>
    <content><![CDATA[<p>C++ 17中<code>std::invoke</code>函数可以用来调用函数、函数指针以及类的成员函数</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">globalFunction</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;globalFunction ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span> <span class="params">( <span class="type">int</span> data )</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\nMyClass memberFunction ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span> <span class="params">( <span class="type">int</span> data )</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;MyClass staticFunction ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::<span class="built_in">invoke</span> ( &amp;MyClass::memberFunction, obj, <span class="number">100</span> );</span><br><span class="line">    std::<span class="built_in">invoke</span> ( &amp;MyClass::staticFunction, <span class="number">200</span> );</span><br><span class="line">    std::<span class="built_in">invoke</span> ( globalFunction );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>《Mastering C++ Programming Modern C++17 at Your Fingertips》</tag>
        <tag>C++17新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 structured binding</title>
    <url>/2023/08/13/C++-17-structured-binding/</url>
    <content><![CDATA[<p>使用C++17的结构化绑定可以根据一个函数的返回值同时定义多个变量，如下所示：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Sriram&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = student;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nName of the student is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age of the student is &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>《Mastering C++ Programming Modern C++17 at Your Fingertips》</tag>
        <tag>C++17新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ initialization list</title>
    <url>/2023/08/13/C++-initialization-list/</url>
    <content><![CDATA[<h3 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1. 初始化列表"></a>1. 初始化列表</h3><p>初始化列表是 C++ 的一种构造对象的方式，它是在构造函数中给对象赋值的一种方式。</p>
<span id="more"></span>

<h3 id="2-初始化列表的语法"><a href="#2-初始化列表的语法" class="headerlink" title="2. 初始化列表的语法"></a>2. 初始化列表的语法</h3><p>初始化列表的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    类成员变量<span class="number">1</span>;类成员变量<span class="number">2</span> ;</span><br><span class="line">    ...</span><br><span class="line">    类成员变量n;</span><br><span class="line">    类成员函数<span class="number">1</span>;</span><br><span class="line">    类成员函数<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    类成员函数n;</span><br><span class="line">    构造函数(参数列表): 初始化列表</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-初始化列表注意事项"><a href="#3-初始化列表注意事项" class="headerlink" title="3. 初始化列表注意事项"></a>3. 初始化列表注意事项</h3><p>在初始化列表中成员变量的初始化顺序并不影响最终成员变量的初始化顺序，而是按照成员变量在类中的声明顺序进行初始化。一般情况下，如果在初始化列表中没有按照成员变量的声明顺序来初始化，也没有问题，但某些情况下可能导致对象并没有真正地被初始化。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// oops!  do you see the problem?</span></span><br><span class="line">   <span class="built_in">X</span>( <span class="type">int</span> val )</span><br><span class="line">      : <span class="built_in">j</span>( val ), <span class="built_in">i</span>( j )</span><br><span class="line">&#123;&#125; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按照上面的初始化列表，程序实际运行的时候，先初始化i, 再初始化j， 最后才调用构造函数。在初始化i的时候，j还没有被初始化，所以i的值是未定义的。</p>
<h3 id="4-带初始化列表的构造函数的写法建议"><a href="#4-带初始化列表的构造函数的写法建议" class="headerlink" title="4. 带初始化列表的构造函数的写法建议"></a>4. 带初始化列表的构造函数的写法建议</h3><p><code>I recommend always placing the initialization of one member with another (if you really feel it is necessary) within the body of the constructor, as follows:  </code>–from <strong>《Inside the c++ object model》</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preferred idiom</span></span><br><span class="line">X::<span class="built_in">X</span>( <span class="type">int</span> val ): <span class="built_in">j</span>( val ) &#123;</span><br><span class="line">    i = j; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要调用成员函数来初始化某个成员的话，最好将该初始化函数放在构造函数里面，以确保成员函数可能依赖的对象状态在此时已经是被初始化好了的。</p>
]]></content>
      <tags>
        <tag>《Inside the C++ object model》</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/09/01/factory-pattern/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>上一篇讲到<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>，简单工厂模式中，我们建立了一个工厂类，当需要某一类对象的时候，将相应参数传给工厂类，由工厂类来决定生成何种对象。但有一个缺点，如果新增一个产品类，那我们将不得不对工厂类进行修改，增加新的业务逻辑，违反了面向对象编程中的开闭原则。</p>
<span id="more"></span>
<p>本文提到的<strong>工厂模式</strong>是对<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>的升级和改进。工厂模式是在简单工厂模式的基础上，对“工厂”添加了一个抽象层。将工厂共同的动作抽象出来，作为抽象类，而具体的行为由子类本身去实现，让子类去决定生产什么样的产品。</p>
<p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<h3 id="示例（已测试）"><a href="#示例（已测试）" class="headerlink" title="示例（已测试）"></a>示例（已测试）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Product</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductA</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is product A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductB</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is product B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product *<span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductAFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductAFactory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductAFactory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function">Product *<span class="title">createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductBFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductBFactory</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ProductBFactory</span>()&#123;&#125;;</span><br><span class="line">    <span class="function">Product *<span class="title">createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *factoryA = <span class="keyword">new</span> <span class="built_in">ProductAFactory</span>();</span><br><span class="line">    Product *productA = factoryA-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productA-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Factory *factoryB = <span class="keyword">new</span> <span class="built_in">ProductBFactory</span>();</span><br><span class="line">    Product *productB = factoryB-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productB-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factoryA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factoryA;</span><br><span class="line">        factoryA = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> productA;</span><br><span class="line">        productA = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factoryB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factoryB;</span><br><span class="line">        factoryB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> productB;</span><br><span class="line">        productB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>This is product A<br>This is product B  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>在本例中ProductAFactory专门负责ProductA类对象的生成，ProductBFactory专门负责ProductB类对象的生成，如果未来需要新增一个类ProductC，则可以直接继承Factory创建一个ProductCFactory类，负责ProductC类对象的生成，并且测试时也只需单独对一类产品进行测试即可，，符合面向对象设计的原则。</p>
</li>
<li><p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<ul>
<li>在设计的初期，就考虑到产品在后期会进行扩展的情况下，可以使用工厂方法模式；</li>
<li>产品结构较复杂的情况下，可以使用工厂方法模式；</li>
</ul>
</li>
<li><p>感想：工厂模式解决了<a href="https://bill_david.gitee.io/2022/08/31/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>简单工厂模式</strong></a>的弊端，即违反了开闭原则。在简单工厂模式中，如果新增一个产品类，则需要对工厂类方法进行修改，违反了开闭原则，但在工厂模式中，工厂类并不负责实际对象的产生，而是将自身<strong>抽象</strong>为一个<strong>接口</strong>，将创建产品对象这一行为推迟到子类中。这样当新增一个产品类时，我们只需要写一个这个类的工厂，继承统一的接口工厂类，然后再实现这个产品类即可，无需对原有的代码进行修改。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/08/31/simple-factory-pattern/</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式(Simple Factory Pattern):又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建类的实例通常具有共同的父类。</p>
<span id="more"></span>
<h3 id="例子-已测试"><a href="#例子-已测试" class="headerlink" title="例子(已测试)"></a>例子(已测试)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">ProductTypeTa</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeA,</span><br><span class="line">    TypeB,</span><br><span class="line">    TypeC</span><br><span class="line">&#125; PRODUCTTYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductC</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is product C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product *<span class="title">create_product</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TypeA:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">        <span class="keyword">case</span> TypeB:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">        <span class="keyword">case</span> TypeC:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductC</span>();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Factory *productFactory = <span class="keyword">new</span> <span class="built_in">Factory</span>();</span><br><span class="line">    Product *productObjA = productFactory-&gt;<span class="built_in">create_product</span>(TypeA);</span><br><span class="line">    <span class="keyword">if</span> (productObjA != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjA-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Product *productObjB = productFactory-&gt;<span class="built_in">create_product</span>(TypeB);</span><br><span class="line">    <span class="keyword">if</span> (productObjB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjB-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Product *productObjC = productFactory-&gt;<span class="built_in">create_product</span>(TypeC);</span><br><span class="line">    <span class="keyword">if</span> (productObjC != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        productObjC-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> productFactory;</span><br><span class="line">    productFactory = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjA;</span><br><span class="line">    productObjA = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjB;</span><br><span class="line">    productObjB = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> productObjC;</span><br><span class="line">    productObjC = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>This is product A<br>This is product B<br>This is product C</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>优点：实现对象的创建和使用分离，创建完全交给专门的工厂类去负责，程序员不需要关心对象是如何创建出来的，只用关心如何使用即可</p>
</li>
<li><p>缺点：不够灵活，在本例中，如果新增一个产品类，就要修改工厂类，修改其判断逻辑。违反了开闭原则，没有办法做到灵活扩展</p>
</li>
<li><p>感想：其实简单工厂模式就是一种分类讨论的思想，根据用户需求的不同生成不同的对象，将这个分类讨论的逻辑放在工厂类里面，最终生成特定类型的对象</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2022/09/01/abstract-factory-pattern/</url>
    <content><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在<a href="https://bill_david.gitee.io/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>工厂模式</strong></a>中提到，为了解决简单工厂模式的不足（不满足开闭原则），工厂模式将工厂类抽象为一个公共类，只定义了基本的接口，而将对象的创建工作推迟到其子类中，这样当我们新增一个产品类的时候，只需要创建一个该产品类对应的工厂，并且继承公共的工厂类即可。</p>
<span id="more"></span>
<p>抽象工厂模式，就好比是多个工厂方法模式的叠加。抽象工厂创建的是一系列相关的对象，其中创建的实现其实就是采用的工厂方法模式。在工厂Factory中的每一个方法，就好比是一条生产线，而生产线实际需要生产什么样的产品，这是由工厂类的子类去决定的，这样便延迟了具体子类的实例化；同时集中化了生产线的管理，节省了资源的浪费。</p>
<h3 id="例子-已测试"><a href="#例子-已测试" class="headerlink" title="例子(已测试)"></a>例子(已测试)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeA</span> : <span class="keyword">public</span> Tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Tree A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeB</span> : <span class="keyword">public</span> Tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Tree B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatA</span> : <span class="keyword">public</span> Cat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Cat A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatB</span> : <span class="keyword">public</span> Cat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Cat B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Tree *<span class="title">createTree</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cat *<span class="title">createCat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory1</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tree *<span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Cat *<span class="title">createCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CatA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory2</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tree *<span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Cat *<span class="title">createCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CatB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *factory1 = <span class="keyword">new</span> <span class="built_in">Factory1</span>();</span><br><span class="line">    Tree *tree1 = factory1-&gt;<span class="built_in">createTree</span>();</span><br><span class="line">    Cat *cat1 = factory1-&gt;<span class="built_in">createCat</span>();</span><br><span class="line"></span><br><span class="line">    tree1-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cat1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Factory *factory2 = <span class="keyword">new</span> <span class="built_in">Factory2</span>();</span><br><span class="line">    Tree *tree2 = factory2-&gt;<span class="built_in">createTree</span>();</span><br><span class="line">    Cat *cat2 = factory2-&gt;<span class="built_in">createCat</span>();</span><br><span class="line"></span><br><span class="line">    tree2-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cat2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factory1;</span><br><span class="line">        factory1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tree1;</span><br><span class="line">        tree1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cat1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> cat1;</span><br><span class="line">        cat1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> factory2;</span><br><span class="line">        factory2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tree2;</span><br><span class="line">        tree2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cat2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> cat2;</span><br><span class="line">        cat2 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>This is Tree A<br>This is Cat A<br>This is Tree B<br>This is Cat B  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>工厂方法模式适用于产品种类结构单一的场合，为一类产品提供创建的接口；而抽象工厂方法适用于产品种类结构多的场合，主要用于创建一组（有多个种类）相关的产品，为它们提供创建的接口；就是当具有多个抽象角色时，抽象工厂便可以派上用场。</li>
<li>简单工厂模式-&gt;工厂模式-&gt;抽象工厂模式 本质上是同一种设计模式，具备层层递进的关系，有利于加深我们对于设计模式的理解和演进</li>
</ul>
]]></content>
      <tags>
        <tag>软件开发</tag>
        <tag>设计模式</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>空类、虚继承</title>
    <url>/2023/08/13/%E7%A9%BA%E7%B1%BB%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h2><p>空类（empty class）是指没有数据成员和成员函数的类。</p>
<p>空类对象的大小为 1 字节，因为编译器会为空类对象分配一个字节的空间，以防止出现意外的内存访问。这样当用户创建两个空类的对象时，就可以保证这两个对象所在的地址不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">X &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>《Inside the C++ Object Model》</tag>
      </tags>
  </entry>
</search>
